---
title: "Assignment2"
author: "Ketaki Rane"
date: "2022-11-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r part A}
library("ggplot2")
library("aqp")
library("soilDB")
library("tidyverse")
library("lubridate")
library("dplyr")


lcdf<-read.csv('C:/SANIDHYA/Fall2022/IDS572/HW2/lcDataSampleFall22.csv')
class(lcdf)
nrow(lcdf)
ncol(lcdf)
View(lcdf)### What are the values for loan_status ?
lcdf %>% group_by(loan_status) %>% tally()
#Are there values other than "fully paid", "charged off" ? Yes
#Keep "Fully Paid' and "Charged Off" status only:
lcdf <- lcdf %>% filter(loan_status == "Fully Paid" | loan_status == "Charged Off")
#What is the proportion of defaults ('charged off' vs 'fully paid' loans) in the data?
ls_tbl <- with(lcdf, table(loan_status))
ls_tbl
# To have labels in Percentage
percent_tbl <-round((prop.table(ls_tbl)*100),2)
percent_tbl
#Plot
colnames(as.data.frame(percent_tbl))
plot1 <-ggplot(data=as.data.frame(percent_tbl), 
               aes(x=loan_status, y=Freq, fill = loan_status)) +
  geom_bar(stat="identity") +  geom_col(position = 'dodge') + 
  xlab("Loan Status") + ylab("Percentage") + labs(fill = "Status") +
  geom_text(aes(label=Freq), vjust=2, size=3 , color='White') + 
  scale_fill_manual(values=c('Black','Orange')) + theme_light()
plot1

### How does loan status vary by loan grade
table(lcdf$loan_status, lcdf$grade)
#Default rate vary with loan grade percent wise?
lcdf_coff <- lcdf[lcdf$loan_status=='Charged Off',]
g_tbl <- with(lcdf_coff, table(grade))
g_tbl
# To have labels in Percentage
per_g_tbl <-round((prop.table(g_tbl)*100),2)
per_g_tbl
#Plot
colnames(as.data.frame(per_g_tbl))
plot2 <-ggplot(data=as.data.frame(per_g_tbl), 
               aes(x=grade, y=Freq, fill = grade)) +
  geom_bar(stat="identity") +  geom_col(position = 'dodge') + 
  xlab("Grades") + ylab("Percentage") + labs(fill = "Grade") +
  geom_text(aes(label=Freq), vjust=-0.2, size=3 , color='Black') + 
  scale_fill_brewer(palette="Paired") + theme_light()
plot2

### Does it vary with sub-grade?
subg_tbl <- with(lcdf_coff, table(grade,sub_grade))
subg_tbl
# To have labels in Percentage
per_subg_tbl <-round((prop.table(subg_tbl)*100),2)
per_subg_tbl
#Plot
colnames(as.data.frame(per_subg_tbl))
plot3 <-ggplot(data=as.data.frame(per_subg_tbl), 
               aes(x=sub_grade, y = Freq, fill = grade)) +
  geom_bar(stat="identity") +  geom_col(position = 'dodge') + 
  xlab("Sub Grade") + ylab("Percentage") + labs(fill = "Grade") +
  geom_text(aes(label=Freq), vjust=0, size=2.5 , color='Black') + 
  scale_fill_brewer(palette="Paired") + theme_light()
plot3

### Does it vary with sub-grade?
sg_tbl <- with(lcdf_coff, table(sub_grade))
sg_tbl
# To have labels in Percentage
per_sg_tbl <-round((prop.table(sg_tbl)*100),2)
per_sg_tbl
#Plot
colnames(as.data.frame(per_sg_tbl))
plot4 <-ggplot(data=as.data.frame(per_sg_tbl), 
               aes(x=sub_grade, y = Freq, fill = sub_grade)) +
  geom_bar(stat="identity") +  geom_col(position = 'dodge') + 
  xlab("Sub Grade") + ylab("Percentage") + labs(fill = "SubGrade") +
  geom_text(aes(label=Freq), vjust=-0.5, size=3 , color='Black') + 
  theme_light()
plot4

#####################
#Part A Q2 II
#####################

#How many loans are there in each grade?
gn_tbl <- with(lcdf, table(grade))
gn_tbl
#Plot
colnames(as.data.frame(gn_tbl))
plot5 <-ggplot(data=as.data.frame(gn_tbl), 
               aes(x=grade, y=Freq, fill=grade)) +
  geom_bar(stat="identity") +  geom_col(position = 'dodge') + 
  xlab("Grades") + ylab("Total Loans") + labs(fill = "Grade") +
  geom_text(aes(label=Freq), vjust=-0.25, size=3 , color='Black') + 
  scale_fill_brewer(palette="Paired") + theme_light()
plot5

#Do loan amounts vary by grade?
lcdf %>% group_by(grade) %>% summarise(sum(loan_amnt))
#Plot
plot6<- ggplot(data=lcdf, 
               mapping = aes(x = grade, y = loan_amnt, fill=grade)) + 
  geom_boxplot() + xlab("Grades") + ylab("Loans Amount") + 
  labs(fill = "Grade") + scale_fill_brewer(palette="Paired") +
  theme_light()
plot6

#Does interest rate for loans vary with grade?
lcdf %>% group_by(grade) %>% summarise(mean(int_rate))
#Plot
plot7<- ggplot(data=lcdf, 
               mapping = aes(x = grade, y = int_rate, fill=grade)) + 
  geom_boxplot() + xlab("Grades") + ylab("Interest Rate") + 
  labs(fill = "Grade") + scale_fill_brewer(palette="Paired") +
  theme_light()
plot7
#Does interest rate for loans vary with subgrade?
lcdf %>% group_by(sub_grade) %>% summarise(mean(int_rate))
#Plot
plot8<- ggplot(data=lcdf, 
               mapping = aes(x = sub_grade, y = int_rate, fill=grade)) + 
  geom_boxplot() + xlab("Sub Grades") + ylab("Interest Rate") + 
  labs(fill = "Sub Grade") + scale_fill_brewer(palette="Paired") +
  theme_light()
plot8

#Look at the average, standard-deviation, min and max of interest rate by grade and subgrade.
asdmimx_ir_g <- lcdf %>% group_by(grade) %>% summarise(avgIR=mean(int_rate), 
                                                       sdIR=sd(int_rate), minIR=min(int_rate),maxIR=max(int_rate))
asdmimx_ir_g

asdmimx_ir_sg <- lcdf %>% group_by(sub_grade) %>% summarise(avgIR=mean(int_rate), 
                                                            sdIR=sd(int_rate),minIR=min(int_rate),maxIR=max(int_rate))
asdmimx_ir_sg

# Write this table to a csv file:   
write.csv(asdmimx_ir_g, "asdmimx_ir_g.csv", row.names = FALSE)
write.csv(asdmimx_ir_sg, "asdmimx_ir_sg.csv", row.names = FALSE)
```

## Including Plots

You can also embed plots, for example:

```{r Part A}

#For loans which are fully paid back, how does the time-to-full-payoff vary?
lcdf_fpaid <- lcdf[lcdf$loan_status=='Fully Paid',]
nrow(lcdf_fpaid)

lcdf_fpaid$actual_term = as.Date(paste("1,",lcdf_fpaid$last_pymnt_d), format="%d, %B-%Y") - as.Date(lcdf_fpaid$issue_d, format="%Y-%m-%d")
lcdf_fpaid$actual_term

#Plot
plot9<- ggplot(data=lcdf_fpaid, 
               mapping = aes(x = grade, y = actual_term, fill=grade)) +
  geom_boxplot() + xlab("Grades") + ylab("Actual Term") + 
  labs(fill = "Grade") + scale_fill_brewer(palette="Paired") +
  theme_light()
plot9


#Need to do
lcdf %>% group_by(loan_status) %>%summarise(avgRec=mean(recoveries))
#ref_tbl

lcdf %>% group_by(loan_status) %>%summarise(recPrncp=mean(total_rec_prncp), 
                                            recInt=mean(total_rec_int), 
                                            recLateFee=mean(total_rec_late_fee),
                                            avgRec=mean(recoveries),
                                            avgPmnt=mean(total_pymnt))


term_tbl <- with(lcdf, table(term))
term_tbl

lcdf$annRet <- ((lcdf$total_pymnt - lcdf$funded_amnt)/lcdf$funded_amnt)*(12/36)*100
# Evidence of return from charged off loan
nrow(filter(lcdf, loan_status=='Charged Off',annRet>0))

ncol(lcdf)
lcdf_annRet_coff<-filter(lcdf, loan_status=='Charged Off')
ncol(lcdf_annRet_coff)
#Plot
plot10<- ggplot(data=lcdf_annRet_coff, 
                mapping = aes(x = grade, y = annRet, fill=grade)) + 
  geom_boxplot() + xlab("Grades") + ylab("Annual Returns") + 
  labs(fill = "Grade") + scale_fill_brewer(palette="Paired") +
  theme_light()
plot10
#Tables
ls_avg_tbl<- lcdf%>% group_by(loan_status) %>% summarise(intRate=mean(int_rate), 
                                                         totRet=mean((total_pymnt - funded_amnt)/funded_amnt)*100)
ls_avg_tbl

g_avg_tbl <- lcdf%>% group_by(grade) %>% summarise(intRate=mean(int_rate), 
                                                   totRet=mean((total_pymnt - funded_amnt)/funded_amnt)*100)
g_avg_tbl

sg_avg_tbl <- lcdf%>% group_by(sub_grade) %>% summarise(intRate=mean(int_rate), 
                                                        totRet=mean((total_pymnt - funded_amnt)/funded_amnt)*100)
sg_avg_tbl

# Write this tables to a csv file:   
write.csv(ls_avg_tbl, "ls_avg_tbl.csv", row.names = FALSE)
write.csv(g_avg_tbl, "g_avg_tbl.csv", row.names = FALSE)
write.csv(sg_avg_tbl, "sg_avg_tbl.csv", row.names = FALSE)
pur_tbl<-lcdf %>% group_by(purpose) %>% summarise(nLoans=n(),
                                                  sumAmnt=sum(loan_amnt),avgAmnt=mean(loan_amnt),
                                                  avgIntr= mean(int_rate),defaults=sum(loan_status=="Charged Off"),
                                                  defaultRate=defaults/nLoans)
pur_tbl

# Do loan amounts vary by purpose?
colnames(as.data.frame(pur_tbl))
#Plot
plot11 <-ggplot(data=as.data.frame(pur_tbl), 
                aes(x=purpose, y=avgAmnt, fill = purpose)) +
  geom_bar(stat="identity")+  geom_col(position = 'dodge') + 
  xlab("Purposes") + ylab("Average Amount") + labs(fill = "Purpose") +
  geom_text(aes(label=avgAmnt), angle = 90,hjust=1, size=4 , color='Black') + 
  theme_light() + theme(axis.text.x = element_text(angle =90, hjust = 1))

plot11
# Do defaults vary by purpose?
dflt_pur_tbl<-lcdf %>% group_by(purpose) %>% summarise("N_cOff"=sum(loan_status=='Charged Off'),
                                                       "N_fPaid"=sum(loan_status=='Fully Paid'),
                                                       "prcnt_defalut"=(sum(loan_status=='Charged Off')/(sum(loan_status=='Charged Off') + 
                                                                                                           sum(loan_status=='Fully Paid'))*100))
dflt_pur_tbl
#Plot
plot12 <-ggplot(data=as.data.frame(dflt_pur_tbl), 
                aes(purpose, prcnt_defalut, fill = purpose)) +
  geom_bar(stat="identity")+  geom_col(position = 'dodge') + 
  xlab("Purposes") + ylab("Default Percent") + labs(fill = "Purpose") +
  geom_text(aes(label=prcnt_defalut), angle =90 ,hjust=1, size=4) +
  theme_light() + theme(axis.text.x = element_text(angle =90, hjust = 1))
plot12

# Does loan-grade assigned by Lending Club vary by purpose?
lg_pur_tbl <- with(lcdf, table(purpose,grade))
lg_pur_tbl
#Plot
plot13 <-ggplot(data=as.data.frame(lg_pur_tbl),
                aes(factor(grade), Freq, fill = purpose)) +
  geom_bar(stat="identity")+  geom_col(position = "fill") + 
  xlab("Grades") + ylab("Loans") + labs(fill = "Purpose") +
  geom_text(aes(label=Freq), vjust = -1 ,size=2) +theme_light()

plot13

######################
#Part A - Q2 - (vi)#
######################

###Borrower Characteristics
#1.employment-length vs loan_amout
#Plot
plot14<- ggplot(data=lcdf, 
                mapping = aes(x = emp_length, y = loan_amnt, fill=emp_length)) +
  xlab("Employment Length") + ylab("Loan Amount") + labs(fill = "Emp Length") +
  geom_boxplot() + scale_fill_brewer(palette="Paired") + theme_light() +
  theme(axis.text.x = element_text(angle =90, hjust = 1))

plot14

#2.employment-length vs loan_status
elvsls_tbl <- with(lcdf, table(emp_length,loan_status))
elvsls_tbl
#Plot
plot15 <-ggplot(data=as.data.frame(elvsls_tbl), 
                aes(emp_length, Freq, fill = loan_status)) +
  geom_bar(stat="identity")+  geom_col(position = "fill") +
  xlab("Employment Length") + ylab("Loans Amount") + labs(fill = "Loan Status") +
  geom_text(aes(label=Freq), vjust=-3.0, size=3) + 
  scale_fill_brewer(palette="Paired") + theme_light()
plot15

#3.employment-length vs grade
elvsgd_tbl <- with(lcdf, table(emp_length,grade))
elvsgd_tbl
#Plot
plot16<-ggplot(data=as.data.frame(elvsgd_tbl), 
               aes(emp_length, Freq, fill = grade)) +
  geom_bar(stat="identity")+  geom_col(position = "fill") + 
  xlab("Employment Length") + ylab("Loans Amount") + labs(fill = "Grades") +
  geom_text(aes(label=Freq), vjust=-2, size=3) + 
  scale_fill_brewer(palette="Paired") + theme_light()
plot16

#4.employment-length vs purpose
elvspur_tbl <- with(lcdf, table(emp_length,purpose))
elvspur_tbl
#Plot
plot17 <-ggplot(data=as.data.frame(elvspur_tbl), 
                aes(emp_length, Freq, fill = purpose)) +
  geom_bar(stat="identity")+  geom_col(position = "fill") + 
  xlab("Employment Length") + ylab("Loans Amount") + labs(fill = "Purpose") +
  geom_text(aes(label=Freq), vjust=-2.0, size=3) +theme_light()
plot17

#5.emp_length vs annRet
#Plot
plot18<-ggplot(data=lcdf, 
               mapping = aes(x = emp_length, y = annRet, fill=emp_length)) + 
  xlab("Employment Length") + ylab("Annual Return") + labs(fill = "Emp Length") +
  geom_boxplot() + scale_fill_brewer(palette="Paired") +
  theme_light()
plot18

#6.annual_inc vs loan_amnt
summary(lcdf$annual_inc)
lcdf$catgAnnInc <- with(lcdf, ifelse(annual_inc <  40000,"low",
                                     ifelse(annual_inc <  55000,"low-mid", 
                                            ifelse(annual_inc <  65000,"mid", 
                                                   ifelse(annual_inc <  85000,"mid-upr", 
                                                          "upr")))))
lcdf$catgAnnInc
#Plot
plot19<- ggplot(data=lcdf, 
                mapping = aes(x = catgAnnInc, y = loan_amnt, fill=catgAnnInc)) +
  xlab("Categorical Annual Income") + ylab("Loan Amount") + labs(fill = "Categories") +
  geom_boxplot() + scale_fill_brewer(palette="Paired") +
  theme_light()
plot19

#7.annual_inc vs loan_status
#Plot
plot20<- ggplot(data=lcdf[lcdf$annual_inc<200000,], 
                mapping = aes(x = loan_status, y = annual_inc, fill=loan_status)) + 
  xlab("Loan Status") + ylab("Annual Income") + labs(fill = "Loan Status") +       
  geom_boxplot() + scale_fill_manual(values=c('Red','Orange'))+ theme_light()
plot20

#8.annual_inc vs grade
#Plot
plot21<- ggplot(data=lcdf[lcdf$annual_inc<200000,], 
                mapping = aes(x = grade, y = annual_inc, fill=grade)) + 
  xlab("Grades") + ylab("Annual Income") + labs(fill = "Grade") +       
  geom_boxplot() + scale_fill_brewer(palette="Paired") +theme_light()
plot21

#9.annual_inc vs purpose
#Plot
plot22<- ggplot(data=lcdf[lcdf$annual_inc<200000,], 
                mapping = aes(x = purpose, y = annual_inc, fill=purpose)) + 
  xlab("Purposes") + ylab("Annual Income") + labs(fill = "Purpose") +       
  geom_boxplot() + theme_light() +theme(axis.text.x = element_text(angle =90, hjust = 1))
plot22

#10.catgAnnInc vs annRet
#Plot
plot23<- ggplot(data=lcdf[lcdf$annRet>-2,], 
                mapping = aes(x = catgAnnInc, y = annRet, fill=catgAnnInc)) + 
  xlab("Categorical Annual Income") + ylab("Annual Return") + labs(fill = "Categories") +
  geom_boxplot() + scale_fill_brewer(palette="Paired") +theme_light()
plot23


#######################

#1.total_ann_inc vs loan_amnt
lcdf$totAnnInc <- with(lcdf, ifelse(is.na(annual_inc_joint), 
                                    annual_inc,annual_inc_joint))
summary(lcdf$totAnnInc)
is.na(lcdf$annual_inc_joint[1])


lcdf$catgTotAnnInc <- with(lcdf, ifelse(totAnnInc <  40000,"low",
                                        ifelse(totAnnInc <  55000,"low-mid", 
                                               ifelse(totAnnInc <  65000,"mid", 
                                                      ifelse(totAnnInc <  85000,"mid-upr", 
                                                             "upr")))))

lcdf$catgTotAnnInc
#Plot
plot24<- ggplot(data=lcdf, 
                mapping = aes(x = catgTotAnnInc, y = loan_amnt, fill=catgTotAnnInc)) + 
  xlab("Categorised Total Annual Income") + ylab("Loan Amount") + labs(fill = "Categories") +       
  geom_boxplot() + scale_fill_brewer(palette="Paired") + theme_light()
plot24


#2.totAnnInc vs loan_status
#Plot
plot25<- ggplot(data=lcdf[lcdf$totAnnInc<200000,], 
                mapping = aes(x = loan_status, y = totAnnInc, fill=loan_status)) + 
  xlab("Loan Status") + ylab("Total Annual Income") + labs(fill = "Loan Status") +       
  geom_boxplot() + scale_fill_manual(values=c('DarkGreen','DarkOrange'))  + theme_light()
plot25

#3.catgTotAnnInc vs annRet
#Plot
plot26<- ggplot(data=lcdf[lcdf$annRet>-2,], 
                mapping = aes(x = catgTotAnnInc, y = annRet, fill=catgTotAnnInc)) + 
  xlab("Categoried Annual Income") + ylab("Annual Return") + labs(fill = "Categories") +       
  geom_boxplot() + scale_fill_brewer(palette="Paired")  + theme_light()
plot26

#4.totAnnInc vs purpose
#Plot
plot27<- ggplot(data=lcdf[lcdf$totAnnInc<200000,], 
                mapping = aes(x = purpose, y = totAnnInc, fill=purpose)) +
  xlab("Purposes") + ylab("Total Annual Income") + labs(fill = "Purpose") +       
  geom_boxplot() + theme_light() + theme(axis.text.x = element_text(angle =90, hjust = 1))
plot27

#5.totAnnInc vs grade
#Plot
plot28<- ggplot(data=lcdf[lcdf$totAnnInc<200000,], 
                mapping = aes(x = grade, y = totAnnInc, fill=grade)) + 
  xlab("Grades") + ylab("Total Annual Income") + labs(fill = "Grade") +       
  geom_boxplot() + scale_fill_brewer(palette="Paired") + theme_bw()
plot28


#################
#Part A -2 b
#################

colMeans(is.na(lcdf))
#list of columns with all NA values
missing_col <- c()
for(i in colnames(lcdf)) {
  if(colMeans(is.na(lcdf[i]))==1) missing_col <- append(missing_col,i) 
}
colnames(lcdf[,missing_col])
#Drop variables with all NA values
lcdf <- lcdf %>% select_if(function(x){!all(is.na(x))})
#still some columns will have partial missing values
is.na(lcdf)
#percentage of missing values in each column
colMeans(is.na(lcdf))
colnames(lcdf)
#index of column with missing value percentage>0
missed <- c()
for(i in 1:ncol(lcdf)) {
  if(length(which(is.na(lcdf[,i]))) > 0) missed <- append(missed,i) 
}
missed
# Percentage of missing value per column
colMeans(is.na(lcdf[,missed]))
# Replacing Missing Values by various techniques
# Here we can replace open_acc_6m variable by 0, as this is a mode among non-empty records.
lcdf$open_acc_6m[is.na(lcdf$open_acc_6m)] <- 0
summary(as.factor(lcdf$open_acc_6m)) 
#Similarly we can put very high values for below columns
lcdf$open_acc_6m[is.na(lcdf$mths_since_last_record)] <- 1000 
lcdf$open_acc_6m[is.na(lcdf$mths_since_recent_bc_dlq)] <- 1000
lcdf$open_acc_6m[is.na(lcdf$mths_since_last_major_derog)] <- 1000
lcdf$open_acc_6m[is.na(lcdf$mths_since_recent_revol_delinq)] <- 1000
lcdf$open_acc_6m[is.na(lcdf$mths_since_last_delinq)] <- 1000   
lcdf$open_acc_6m[is.na(lcdf$mths_since_recent_inq)] <- 1000
#replacing by median for bc_open_to_buy
lcdf<- lcdf %>% replace_na(list(bc_open_to_buy=median(lcdf$bc_open_to_buy, na.rm=TRUE)))
# Replacing the missing values as mentioned in Word/pdf file.
lcdf<- lcdf %>% replace_na(list(mths_since_last_delinq=-1000, 
                                bc_open_to_buy=median(lcdf$bc_open_to_buy, na.rm=TRUE), 
                                mo_sin_old_il_acct=1000, mths_since_recent_bc=1000, 
                                mths_since_recent_inq=50, num_tl_120dpd_2m = median(lcdf$num_tl_120dpd_2m, 
                                                                                    na.rm=TRUE),percent_bc_gt_75 = median(lcdf$percent_bc_gt_75, 
                                                                                                                          na.rm=TRUE), bc_util=median(lcdf$bc_util, na.rm=TRUE)))
#Dropping columns with more than 60% null
sixtyPlus<-names(lcdf)[colMeans(is.na(lcdf))>0.6]
lcdf <- lcdf %>% select (-sixtyPlus)
colnames(lcdf)


##############

##############

library(pROC) 
library(broom)

#One hot encoding for emp_length
lcdf<-lcdf %>% mutate(e_emp_length = case_when(
  emp_length == '< 1 year' ~0.5,
  emp_length == '1 year'   ~1.0,
  emp_length == '10+ years'~10.0,
  emp_length == '2 years'  ~2.0,
  emp_length == '3 years'  ~3.0,
  emp_length == '4 years'  ~4.0,
  emp_length == '5 years'  ~5.0,
  emp_length == '6 years'  ~6.0,
  emp_length == '7 years'  ~7.0,
  emp_length == '8 years'  ~8.0,
  emp_length == '9 years'  ~9.0,
  is.na(emp_length) ~0.0))
# replacing NA to 0
lcdf$e_emp_length[is.na(lcdf$e_emp_length)] <- 0


#One hot encoding for grade
lcdf<-lcdf %>% mutate(e_grade = case_when(
  grade == 'G' ~1.0,
  grade == 'F' ~2.0, 
  grade == 'E' ~3.0,
  grade == 'D' ~4.0,
  grade == 'C' ~5.0,
  grade == 'B' ~6.0,
  grade == 'A' ~7.0))
# replacing NA to 0
lcdf$e_emp_length[is.na(lcdf$e_grade)] <- 0


#One hot encoding for home_ownership
lcdf<-lcdf %>% mutate(e_home_ownership = case_when(
  home_ownership == 'RENT' ~1.0,
  home_ownership == 'MORTGAGE' ~3.0,
  home_ownership == 'OWN' ~5.0))
# replacing NA to 0
lcdf$e_emp_length[is.na(lcdf$e_home_ownership)] <- 0


#One hot encoding for verification_status
as.data.frame(table(lcdf$verification_status))
lcdf<-lcdf %>% mutate(e_verification_status = case_when(
  verification_status == 'Not Verified' ~1.0,
  verification_status == 'Source Verified' ~3.0,
  verification_status == 'Verified' ~5.0))
# replacing NA to 0
lcdf$e_emp_length[is.na(lcdf$mths_since_last_delinq)] <- 0
lcdf$e_emp_length[is.na(lcdf$avg_cur_bal)] <- 0
lcdf$e_emp_length[is.na(lcdf$mths_since_last_record)] <- 0
lcdf$e_emp_length[is.na(lcdf$revol_util)] <- 0
lcdf$e_emp_length[is.na(lcdf$mths_since_last_delinq)] <- 0
lcdf$e_emp_length[is.na(lcdf$e_verification_status)] <- 0

#New variables
lcdf$annRet <- ((lcdf$total_pymnt - lcdf$funded_amnt)/lcdf$funded_amnt)*(12/36)*100
lcdf$last_pymnt_d<-paste(lcdf$last_pymnt_d, "-01", sep = "")
lcdf$last_pymnt_d<-parse_date_time(lcdf$last_pymnt_d,  "myd")
head(lcdf[, c("last_pymnt_d", "issue_d")])
lcdf$actualTerm <- ifelse(lcdf$loan_status=="Fully Paid", as.duration(lcdf$issue_d  %--% lcdf$last_pymnt_d)/dyears(1), 3)
lcdf$actualReturn <- ifelse(lcdf$actualTerm>0, ((lcdf$total_pymnt - lcdf$funded_amnt)/lcdf$funded_amnt)*(1/lcdf$actualTerm)*100, 0)

#AUC
for (i in c("int_rate","e_grade","acc_open_past_24mths","annual_inc",
            "tot_hi_cred_lim","total_bc_limit","avg_cur_bal",
            "tot_cur_bal","mo_sin_rcnt_tl","mths_since_recent_inq",
            "mort_acc","mo_sin_old_rev_tl_op","bc_util","e_home_ownership",
            "revol_bal","mo_sin_old_il_acct","loan_amnt","num_op_rev_tl",
            "pct_tl_nvr_dlq","total_il_high_credit_limit","mths_since_last_delinq",
            "num_il_tl","open_acc","num_sats","installment","open_acc_6m")) 
{
  print(auc(response=lcdf[["loan_status"]],as.numeric(lcdf[[i]])))
}

#Numeric variables:
AUCNum <- sapply(lcdf %>% select_if(is.numeric), auc, response=lcdf$loan_status)
#Numeric and Factor variables:
AUCAll<- sapply(lcdf %>% mutate_if(is.factor, as.numeric) %>% select_if(is.numeric), 
                auc, response=lcdf$loan_status) 
tidy(AUCAll) %>% view()
#Variables have AUC > 0.5
AUCAll[AUCAll>0.5]
#arranged in descending order to get important variable
tidy(AUCAll) %>% arrange(desc(AUCAll))
# Using tidy(..) function we converts the 'messy' output into a tidy form as a tibble
tidy(AUCAll[AUCAll > 0.5]) %>% view()
auc_call<-tidy(AUCAll[AUCAll > 0.5])
write.csv(auc_call, "auc_call.csv", row.names = FALSE)


#Finding AUC to again Plotting graph for important variable
roc_loan_amnt <- roc(lcdf[["loan_status"]], lcdf[["loan_amnt"]])
roc_annual_inc <- roc(lcdf[["loan_status"]], lcdf[["annual_inc"]])
roc_int_rate <- roc(lcdf[["loan_status"]], lcdf[["int_rate"]])

plot(roc_loan_amnt, print.auc=FALSE, col="blue", lty=1, lwd=2, legacy.axes = TRUE, print.auc.y=.35, grid=TRUE)
plot(roc_annual_inc, print.auc=FALSE, col="green", lty=2, lwd=2, legacy.axes = TRUE, print.auc.y=.3, grid=TRUE, add=TRUE)
plot(roc_int_rate, print.auc=FALSE, col="red", lty=3, lwd=2, legacy.axes = TRUE, print.auc.y=.3, grid=TRUE, add=TRUE)
legend("bottomright",
       legend=c("loan_amnt" , "annual_inc" , "int_rate"),
       col=c("blue", "green", "red"),  
       lty=c(1,5),
       lwd=c(1,1))




roc_installment <- roc(lcdf[["loan_status"]], lcdf[["installment"]])
roc_e_grade <- roc(lcdf[["loan_status"]], lcdf[["e_grade"]])


plot(roc_installment, print.auc=FALSE, col="DarkOrange", lty=2, lwd=2, legacy.axes = TRUE, print.auc.y=.3, grid=TRUE)
plot(roc_e_grade, print.auc=FALSE, col="Green", lty=3, lwd=2, legacy.axes = TRUE, print.auc.y=.3, grid=TRUE, add=TRUE)




library(rpart)
library(ROCR)

#70% training sample
TRAIN_PROP = 0.7 

rownum<-nrow(lcdf)
trainIndex<- sample(1:rownum, size = round(TRAIN_PROP * rownum), replace=FALSE)

lcdfTrain <- lcdf[trainIndex, ]
lcdfTest <- lcdf[-trainIndex, ]

unique(lcdfTrain$sub_grade)
unique(lcdfTest$sub_grade)

#Verifying  Data
glimpse(lcdf)
colnames(lcdf)
str(lcdf)



#loan_status to  a factor variable
lcdf$loan_status <- factor(lcdf$loan_status, levels=c("Fully Paid", "Charged Off"))
DTree1 <- rpart(loan_status ~., data=lcdfTrain, method="class", parms = list(split = "information"), 
                control = rpart.control(cp=0.0001, minsplit = 50))
#Tree
table(pred=predict(DTree1,lcdfTrain, type="class"), true=lcdfTrain$loan_status)

#Now removing data leakage variables
varsOmit<-c("annRet","addr_state","bc_open_to_buy","collection_recovery_fee",
            "collections_12_mths_ex_med","debt_settlement_flag","delinq_amnt",
            "disbursement_method","dti","e_emp_length","e_grade","e_home_ownership",
            "e_verification_status","emp_title","funded_amnt","funded_amnt_inv",
            "hardship_flag","inq_last_6mths","issue_d","last_credit_pull_d",
            "last_pymnt_amnt","last_pymnt_d","mo_sin_rcnt_rev_tl_op",
            "mths_since_recent_bc","num_actv_bc_tl","num_bc_tl","num_rev_accts",
            "num_tl_120dpd_2m","num_tl_op_past_12m","out_prncp","out_prncp_inv",
            "policy_code","pub_rec_bankruptcies","pymnt_plan","recoveries","revol_util",
            "term","title","tot_coll_amt","total_acc","total_bal_ex_mort","total_pymnt",
            "total_pymnt_inv","total_rec_int","total_rec_late_fee","total_rec_prncp",
            "total_rev_hi_lim","zip_code","earliest_cr_line","actualTerm","actualReturn")

#############################################
# With no Parameters
DTree2 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class" )
DTree2

# With no Parameters - Model evaluation (Confusion Matrix, ROC Plot, AUC Value, Lift Curve)
table(pred=predict(DTree2,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree2,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(DTree2,lcdfTest, type="prob")[,2]
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)
###############################################
# Parameters - Split=information, CP Value:0.0001
DTree3 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                parms = list(split = "information"), control = rpart.control(cp=0.0001))
DTree3
table(pred=predict(DTree3,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree3,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(DTree3,lcdfTest, type="prob")[,2]
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

###############################################################
# Parameters - Split=information, CP Value:0.0001, minsplit=50
DTree4 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                parms = list(split = "information"), control = rpart.control(cp=0.0001, minsplit = 50))
DTree4
table(pred=predict(DTree4,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree4,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(DTree4,lcdfTest, type="prob")[,2]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

###############################################################
# Parameters - Split=information, CP Value:0.0001, minsplit=30
DTree5 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                parms = list(split = "information"), control = rpart.control(cp=0.0001, minsplit = 30))
DTree5
table(pred=predict(DTree5,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree5,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(DTree5,lcdfTest, type="prob")[,2]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

###################################################################
# Parameters - Split=information, CP Value:0.000001, minsplit=30
DTree6 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                parms = list(split = "information"), control = rpart.control(cp=0.000001, minsplit = 30))
DTree6
table(pred=predict(DTree6,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree6,lcdfTest, type="class"), true=lcdfTest$loan_status)


score=predict(DTree6,lcdfTest, type="prob")[,2]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))



#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

##################################################################
# Parameters - Split=information, CP Value:0.000001, minsplit=100
DTree7 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                parms = list(split = "information"), control = rpart.control(cp=0.000001, minsplit = 100))
DTree7
table(pred=predict(DTree7,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree7,lcdfTest, type="class"), true=lcdfTest$loan_status)


score=predict(DTree7,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

############################################
# Parameters - Split=gini, CP Value:0.0001
DTree8 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                parms = list(split = "gini"), control = rpart.control(cp=0.0001))
DTree8
table(pred=predict(DTree8,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree8,lcdfTest, type="class"), true=lcdfTest$loan_status)


score=predict(DTree8,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

############################################################
# Parameters - Split=gini, CP Value:0.0001, minsplit=50
DTree9 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class",
                parms = list(split = "gini"), control = rpart.control(cp=0.0001, minsplit = 50))
DTree9
table(pred=predict(DTree9,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree9,lcdfTest, type="class"), true=lcdfTest$loan_status)

plot(DTree9)

score=predict(DTree9,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

##########################################################
# Parameters - Split=gini, CP Value:0.0001, minsplit=30
DTree10 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                 parms = list(split = "gini"), control = rpart.control(cp=0.0001, minsplit = 30))
DTree10
table(pred=predict(DTree10,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree10,lcdfTest, type="class"), true=lcdfTest$loan_status)


score=predict(DTree10,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

############################################################
# Parameters - Split=gini, CP Value:0.000001, minsplit=30
DTree11 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                 parms = list(split = "gini"), control = rpart.control(cp=0.000001, minsplit = 30))
DTree11
table(pred=predict(DTree11,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree11,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(DTree11,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values


#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

##########################################################
# Parameters - Split=gini, CP Value:0.000001, minsplit=100
DTree12 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                 parms = list(split = "gini"), control = rpart.control(cp=0.000001, minsplit = 100))
DTree12

table(pred=predict(DTree12,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree12,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(DTree12,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values


#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

#Plot
plot(DTree12)

library(rpart.plot)
png("tree.png", width=5000, height=4000)
rpart.plot(DTree12, main="Classification Tree")
dev.off()

####################################################################
# C50 decision trees
library(C50)

###########################################
# model Parameter : CF - 0.4, MINCASES - 10
c5_DT1 <-C5.0(as.factor(loan_status) ~ ., data=lcdfTrain %>% select(-varsOmit), 
              control=C5.0Control(CF=0.4,minCases=10))

table(pred=predict(c5_DT1,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(c5_DT1,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(c5_DT1,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)


###########################################
# model Parameter : CF - 0.5, MINCASES - 10
c5_DT2 <-C5.0(as.factor(loan_status) ~ ., data=lcdfTrain %>% select(-varsOmit), 
              control=C5.0Control(CF=0.5,minCases=10))

table(pred=predict(c5_DT2,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(c5_DT2,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(c5_DT2,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

#################################################################
# model Parameter : CF - 0.4, MINCASES - 10, noGlobalPruning=TRUE
c5_DT3 <-C5.0(as.factor(loan_status) ~ ., data=lcdfTrain %>% select(-varsOmit), 
              control=C5.0Control(CF=0.4,minCases=10,noGlobalPruning=TRUE))

table(pred=predict(c5_DT3,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(c5_DT3,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(c5_DT3,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

#################################################################
# model Parameter : CF - 0.5, MINCASES - 10, noGlobalPruning=TRUE
c5_DT4 <-C5.0(as.factor(loan_status) ~ ., data=lcdfTrain %>% select(-varsOmit), control=C5.0Control(CF=0.5,minCases=10,noGlobalPruning=TRUE))

table(pred=predict(c5_DT4,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(c5_DT4,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(c5_DT4,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

#################

#################

# pruning the best tree and checking performance with different cp levels
DTree12p<- prune.rpart(DTree12, cp=0.00000000000005)
printcp(DTree12p)
plotcp(DTree12p)

table(pred=predict(DTree12p,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree12p,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(DTree12p,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

# pruning the best tree doesn't improve model performance

#Finding important variables for best rPart model

DTree12$variable.importance


##############
##############

library(caret)
library(ranger)

#Best Random Forest Model
#Running loop through all possible combination of parameters to obtain best combination of parameter

for (nt in c(500))
{
  for (mt in c(9))
  {
    for (imp in c('permutation'))
    {
      for (pb in c(TRUE))
      {
        for (mns in c(10))
        {
          for (md in c(10))
          {
            for (sr in c("gini"))
            {
              for (rf in c(0.1))
              {
                
                brf <- ranger(as.factor(loan_status) ~., 
                              data=subset(lcdfTrain, select=-c(annRet,addr_state,
                                                               bc_open_to_buy,collection_recovery_fee,collections_12_mths_ex_med,
                                                               debt_settlement_flag,delinq_amnt,disbursement_method,dti,e_emp_length,
                                                               e_grade,e_home_ownership,e_verification_status,emp_title,funded_amnt,
                                                               funded_amnt_inv,hardship_flag,inq_last_6mths,issue_d,last_credit_pull_d,
                                                               last_pymnt_amnt,last_pymnt_d,mo_sin_rcnt_rev_tl_op,mths_since_recent_bc,
                                                               num_actv_bc_tl,num_bc_tl,num_rev_accts,num_tl_120dpd_2m,num_tl_op_past_12m,
                                                               out_prncp,out_prncp_inv,policy_code,pub_rec_bankruptcies,pymnt_plan,
                                                               recoveries,revol_util,term,title,tot_coll_amt,total_acc,total_bal_ex_mort,
                                                               total_pymnt,total_pymnt_inv,total_rec_int,total_rec_late_fee,total_rec_prncp,
                                                               total_rev_hi_lim,zip_code,earliest_cr_line,actualTerm,actualReturn,tot_cur_bal, 
                                                               acc_open_past_24mths, avg_cur_bal, mo_sin_old_rev_tl_op, mo_sin_rcnt_tl, 
                                                               mort_acc, num_accts_ever_120_pd, num_actv_rev_tl, num_bc_sats, num_il_tl, 
                                                               num_op_rev_tl, num_rev_tl_bal_gt_0, num_sats, num_tl_30dpd, num_tl_90g_dpd_24m, 
                                                               pct_tl_nvr_dlq, tot_hi_cred_lim, total_bc_limit, total_il_high_credit_limit)), 
                              num.trees=nt,mtry=mt,importance=imp,
                              probability = pb,min.node.size=mns,max.depth=md,splitrule=sr,
                              regularization.factor=rf)
                
                
                scores=predict(brf, lcdfTrain,type="response")$predictions
                scores<-scores[,2]
                head(scores)
                
                predData = ifelse(scores >= 0.5,"Fully Paid", "Charged Off") 
                predData <- as.factor(predData)
                #print(confusionMatrix(predData, as.factor(dfTrn$loan_status)))
                
                
                scores=predict(brf, lcdfTest,type="response")$predictions 
                head(scores)
                scores<-scores[,2]
                head(scores)
                
                predData = ifelse(scores >= 0.5, "Fully Paid", "Charged Off") 
                predData <- as.factor(predData)
                #print(confusionMatrix(predData, as.factor(dfTst$loan_status)))
                
                #ROC Curve
                pred <- predict(brf, data = lcdfTest, num.trees = nt, type='response', verbose = TRUE)
                pred_object <- prediction(pred$predictions[,2], lcdfTest$loan_status)
                
                #AUC value
                aucPerf=performance(pred_object, "auc")
                print(aucPerf@y.values)
                if (aucPerf@y.values>0.6720) 
                {
                  print("num_trees: ")
                  print(nt)
                  print("mtry: ") 
                  print(mt)
                  print("importance: ") 
                  print(imp)
                  print("probability: ") 
                  print(pb)
                  print("minimum_nod_size: ") 
                  print(mns)
                  print("max_depth: ") 
                  print(md)
                  print("splitrule: ") 
                  print(sr)
                  print("regularization_factor: ") 
                  print(rf)
                }
                print('---------------------------------------')
              }
            }  
          }
        }
      }
    }
  }
}
###############################################################################
#For Best Random Forest Tree
#Parameter - num.trees =500, importance='permutation', probability = TRUE
rfModel1 <- ranger(as.factor(loan_status) ~., 
                   data=subset(lcdfTrain, select=-c(annRet,addr_state,
                                                    bc_open_to_buy,collection_recovery_fee,collections_12_mths_ex_med,
                                                    debt_settlement_flag,delinq_amnt,disbursement_method,dti,e_emp_length,
                                                    e_grade,e_home_ownership,e_verification_status,emp_title,funded_amnt,
                                                    funded_amnt_inv,hardship_flag,inq_last_6mths,issue_d,last_credit_pull_d,
                                                    last_pymnt_amnt,last_pymnt_d,mo_sin_rcnt_rev_tl_op,mths_since_recent_bc,
                                                    num_actv_bc_tl,num_bc_tl,num_rev_accts,num_tl_120dpd_2m,num_tl_op_past_12m,
                                                    out_prncp,out_prncp_inv,policy_code,pub_rec_bankruptcies,pymnt_plan,
                                                    recoveries,revol_util,term,title,tot_coll_amt,total_acc,total_bal_ex_mort,
                                                    total_pymnt,total_pymnt_inv,total_rec_int,total_rec_late_fee,total_rec_prncp,
                                                    total_rev_hi_lim,zip_code,earliest_cr_line,actualTerm,actualReturn,
                                                    avg_cur_bal,pct_tl_nvr_dlq,tot_cur_bal, acc_open_past_24mths, 
                                                    mo_sin_old_rev_tl_op, mo_sin_rcnt_tl, mort_acc, num_accts_ever_120_pd, 
                                                    num_actv_rev_tl, num_bc_sats, num_il_tl, num_op_rev_tl, num_rev_tl_bal_gt_0, 
                                                    num_sats, num_tl_30dpd, num_tl_90g_dpd_24m, tot_hi_cred_lim, total_bc_limit, 
                                                    total_il_high_credit_limit)), 
                   num.trees=500,mtry=9,importance="permutation", probability= TRUE ,
                   min.node.size=10,max.depth=10,splitrule="gini",regularization.factor=1)

importance(rfModel1)


rfModel1$confusion.matrix

#confusion matrix
print('Train')
scores=predict(rfModel1, lcdfTrain,type="response")$predictions
scores<-scores[,2]
head(scores)

predData = ifelse(scores >= 0.5,"Fully Paid", "Charged Off") 
predData <- as.factor(predData)
confusionMatrix(predData, as.factor(lcdfTrain$loan_status))

print('Test')
scores=predict(rfModel1, lcdfTest,type="response")$predictions 
head(scores)
scores<-scores[,2]
head(scores)

predData = ifelse(scores >= 0.5, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
confusionMatrix(predData, as.factor(lcdfTest$loan_status))

score=predict(rfModel1,lcdfTest)
score$predictions
pred=prediction(score$predictions[,2], lcdfTest$loan_status)


#ROC Curve
pred <- predict(rfModel1, data = lcdfTest, num.trees = 500, type='response', verbose = TRUE)
pred_object <- prediction(pred$predictions[,2], lcdfTest$loan_status)
per_measure <- performance(pred_object, "tnr", "fnr")
plot(per_measure, col="red", lwd=1)
abline(a=0,b=1,lwd=1,lty=1,col="grey")

#AUC value
aucPerf=performance(pred_object, "auc")
aucPerf@y.values

#Lift curve
liftPerf <-performance(pred_object, "lift", "rpp")
plot(liftPerf, col="red", lwd=1)


#################

#################

# Best Parameters for rpart - Split=gini, CP Value:0.000001, minsplit=100
DTree12 <- rpart(loan_status ~., data=lcdfTrain %>% select(-varsOmit), method="class", 
                 parms = list(split = "gini"), control = rpart.control(cp=0.000001, minsplit = 100))
DTree12

table(pred=predict(DTree12,lcdfTrain, type="class"), true=lcdfTrain$loan_status)
table(pred=predict(DTree12,lcdfTest, type="class"), true=lcdfTest$loan_status)

score=predict(DTree12,lcdfTest, type="prob")[,"Charged Off"]
score
pred=prediction(score, lcdfTest$loan_status, label.ordering = c("Fully Paid", "Charged Off"))

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values

for (CTHRESH in c(0.1,0.2,0.25,0.3,0.4)){
  
  print("----------------------------------")
  print("CTHRESH Value at")
  print(CTHRESH)
  
  predProbTst=predict(DTree12,lcdfTest, type='prob')
  predTstCT = ifelse(predProbTst[, 'Charged Off'] > CTHRESH, 'Charged Off', 'Fully Paid')
  cmdf=as.data.frame(table(predTstCT , true=lcdfTest$loan_status))
  
  
  TP <- filter(cmdf,predTstCT == "Charged Off" & true=='Charged Off') %>% select(Freq)
  FP <- filter(cmdf,predTstCT == "Charged Off" & true=='Fully Paid') %>% select(Freq)
  TN <- filter(cmdf,predTstCT == "Fully Paid" & true=='Fully Paid') %>% select(Freq)
  FN <- filter(cmdf,predTstCT == "Fully Paid" & true=='Charged Off') %>% select(Freq)
  
  
  TPR=TP/(TP+FP)
  FPR=FP/(FP+TN)
  Accuracy=(TP+TN)/(TP+TN+FP+FN)
  Precision=TP/(TP+FP)
  Specificity=1-FPR
  F_Score = (2*Precision*TPR)/(Precision+TPR)
  
  print("Accuracy: ") 
  print(Accuracy)
  print("TPR: ") 
  print(TPR)
  print("FPR: ") 
  print(FPR)
  print("Precision: ") 
  print(Precision)
  print("Specificity: ") 
  print(Specificity)
  print("F_Score: ") 
  print(F_Score)
  
  print("Profit from accurately identifying Fully_paid loans (at 24)")
  profit=TN*24
  print(profit)
  print("Loss from incorrectly predicting a Charged_Off loan as Full_paid (at -35)")
  loss=FP*-35
  print(loss)
  print("Overall Profit")
  print(profit-loss)
  print("----------------------------------------")
  
}


##########################################################################################
# Best Parameters for RF - mtry: 9, importance: "permutation", probability: TRUE, minimum_nod_size: 10, max_depth: 10, splitrule: "gini", regularization_factor: 1

best_rfModel <- ranger(as.factor(loan_status) ~., 
                       data=subset(lcdfTrain, select=-c(annRet,addr_state,
                                                        bc_open_to_buy,collection_recovery_fee,collections_12_mths_ex_med,
                                                        debt_settlement_flag,delinq_amnt,disbursement_method,dti,e_emp_length,
                                                        e_grade,e_home_ownership,e_verification_status,emp_title,funded_amnt,
                                                        funded_amnt_inv,hardship_flag,inq_last_6mths,issue_d,last_credit_pull_d,
                                                        last_pymnt_amnt,last_pymnt_d,mo_sin_rcnt_rev_tl_op,mths_since_recent_bc,
                                                        num_actv_bc_tl,num_bc_tl,num_rev_accts,num_tl_120dpd_2m,num_tl_op_past_12m,
                                                        out_prncp,out_prncp_inv,policy_code,pub_rec_bankruptcies,pymnt_plan,
                                                        recoveries,revol_util,term,title,tot_coll_amt,total_acc,total_bal_ex_mort,
                                                        total_pymnt,total_pymnt_inv,total_rec_int,total_rec_late_fee,total_rec_prncp,
                                                        total_rev_hi_lim,zip_code,earliest_cr_line,actualTerm,actualReturn,
                                                        avg_cur_bal,pct_tl_nvr_dlq,tot_cur_bal, acc_open_past_24mths, 
                                                        mo_sin_old_rev_tl_op, mo_sin_rcnt_tl, mort_acc, num_accts_ever_120_pd, 
                                                        num_actv_rev_tl, num_bc_sats, num_il_tl, num_op_rev_tl, num_rev_tl_bal_gt_0, 
                                                        num_sats, num_tl_30dpd, num_tl_90g_dpd_24m, tot_hi_cred_lim, total_bc_limit, 
                                                        total_il_high_credit_limit)), 
                       num.trees=500,mtry=9,importance="permutation", probability= TRUE ,
                       min.node.size=10,max.depth=10,splitrule="gini",regularization.factor=1)


importance_variable<-importance(best_rfModel)
importance_variable
scores=predict(best_rfModel, lcdfTest,type="response")$predictions 
head(scores)
scores<-scores[,2]
head(scores)

#ROC Curve
pred <- predict(best_rfModel, data = lcdfTest, num.trees = 500, type='response', verbose = TRUE)
pred_object <- prediction(pred$predictions[,2], lcdfTest$loan_status)
per_measure <- performance(pred_object, "tnr", "fnr")
plot(per_measure, col="red", lwd=1)
abline(a=0,b=1,lwd=1,lty=1,col="gray")
#AUC value
aucPerf=performance(pred_object, "auc")
print(aucPerf@y.values)
#Lift curve
liftPerf <-performance(pred_object, "lift", "rpp")
plot(liftPerf)

# for CTHRESH = 0.9
predData = ifelse(scores >= 0.9, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(lcdfTest$loan_status)))

# for CTHRESH = 0.8
predData = ifelse(scores >= 0.8, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(lcdfTest$loan_status)))

# for CTHRESH = 0.75
predData = ifelse(scores >= 0.75, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(lcdfTest$loan_status)))

# for CTHRESH = 0.7
predData = ifelse(scores >= 0.7, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(lcdfTest$loan_status)))

# for CTHRESH = 0.6
predData = ifelse(scores >= 0.6, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(lcdfTest$loan_status)))


#################

#################

PROFITVAL <- 24
COSTVAL <- -35
#Performance
scoreTstRF<-predict(best_rfModel, lcdfTest,type="response")$predictions 
scoreTstRF<-scoreTstRF[,2]
prPerfRF <- data.frame(scoreTstRF)
prPerfRF <- cbind(prPerfRF, status=lcdfTest$loan_status)
prPerfRF <- prPerfRF[order(-scoreTstRF) ,] #sort in desc order of prob(fully_paid)
prPerfRF$profit <- ifelse(prPerfRF$status == 'Fully Paid', PROFITVAL, COSTVAL)
prPerfRF$cumProfit <- cumsum(prPerfRF$profit)
max(prPerfRF$cumProfit)
prPerfRF$cumProfit[which.max(prPerfRF$cumProfit)]
view(prPerfRF)

prPerfRF <- cbind(prPerfRF, int_rate=lcdfTest$int_rate)
prPerfRF <- cbind(prPerfRF, grade=lcdfTest$grade)
prPerfRF <- cbind(prPerfRF, sub_grade=lcdfTest$sub_grade)
prPerfRF <- cbind(prPerfRF, annRet=lcdfTest$annRet)
prPerfRF <- cbind(prPerfRF, actualReturn=lcdfTest$actualReturn)
prPerfRF <- cbind(prPerfRF, actualTerm=lcdfTest$actualTerm)

invest_prPerfRF<- prPerfRF[prPerfRF$scoreTstRF>0.5925740,]

#status wise Avg return, avg int and avg term
invest_prPerfRF<- prPerfRF %>% group_by(status) %>% summarise(avgInt=mean(int_rate), 
                                                              avgRet=mean(actualReturn), 
                                                              avgTerm=mean(actualTerm))
invest_prPerfRF<-as.data.frame(invest_prPerfRF)
invest_prPerfRF
#adding interate for normal bank deposite & assume we want to invest 10000
invest_prPerfRF$Deposite_Int <- 2.0
invest_prPerfRF$investment <- 1000

#Calculating returns
invest_prPerfRF$deposite_return<- (invest_prPerfRF$investment)*(1+((invest_prPerfRF$Deposite_Int)/100))^(invest_prPerfRF$avgTerm)
invest_prPerfRF$Lading_Club_return<-(invest_prPerfRF$investment)*(1+((invest_prPerfRF$avgInt)/100))^(invest_prPerfRF$avgTerm)
invest_prPerfRF
# here we see the difference between the amount we earn through bank and Landing club. Smartly Invest!


```

################################################################
PART B
################################################################

```{r}
library("ggplot2")
library("aqp")
library("soilDB")
library("tidyverse")
library("lubridate")
getwd()
setwd("C:/SANIDHYA/Fall2022/IDS572/HW2")
getwd()
df <- read.csv('lcDataSampleFall22.csv')
#class(df)
#View(df)
#nrow(df)
#ncol(df)
#colnames(df)
#str(df)

####################################
#----- Q2 - C ---------------------#
####################################

df$last_pymnt_d<-paste(df$last_pymnt_d, "-01", sep = "")
# conversion of character to a data type variable
df$last_pymnt_d <- parse_date_time(df$last_pymnt_d,  "myd")

#actual term
df$actualTerm <- ifelse(df$loan_status=="Fully Paid", as.duration(df$issue_d  %--% df$last_pymnt_d)/dyears(1), 3)

#actual annual return 
df$actualReturn <- ifelse(df$actualTerm>0, ((df$total_pymnt -df$funded_amnt)/df$funded_amnt)*(1/df$actualTerm)*100, 0)

#find the annualized percentage return
df$annRet <- ((df$total_pymnt -df$funded_amnt)/df$funded_amnt)*(12/36)*100
df$num_sats <- replace(df$num_sats, df$num_sats == 0, 1)
df$num_acc_ratio <- (df$num_accts_ever_120_pd/df$num_sats)
df$inc_instal_ratio <- (df$annual_inc/df$installment)
df$available_bal_instal_ratio <- ((df$tot_cur_bal - df$revol_bal)/df$installment )

#check proportions of null values
colMeans(is.na(df))


#drop all the columns where all cells are null
df <- df %>% select_if(function(x){!all(is.na(x))})

#drop all columns where more than 50% data is missing
df = df[,!sapply(df, function(x) mean(is.na(x)))>0.5]



#store all columns with more than 1 null values in a separate variable
n <- names(df)[colMeans(is.na(df))>0]
summary(df[, n])

df$num_acc_ratio[is.nan(df$num_acc_ratio)]<-NA
df$inc_instal_ratio[is.nan(df$inc_instal_ratio)]<-NA
df$available_bal_instal_ratio[is.nan(df$available_bal_instal_ratio)]<-NA
df


df <- df %>% replace_na(list(mths_since_last_delinq=median(df$mths_since_last_delinq, na.rm=TRUE), bc_open_to_buy=median(df$bc_open_to_buy, na.rm=TRUE), mo_sin_old_il_acct=median(df$mo_sin_old_il_acct, na.rm=TRUE), mths_since_recent_bc= median(df$mths_since_recent_bc, na.rm=TRUE) , mths_since_recent_inq= median(df$mths_since_recent_inq, na.rm=TRUE), num_tl_120dpd_2m = median(df$num_tl_120dpd_2m, na.rm=TRUE),percent_bc_gt_75 = median(df$percent_bc_gt_75, na.rm=TRUE), bc_util=median(df$bc_util, na.rm=TRUE),pct_tl_nvr_dlq=median(df$pct_tl_nvr_dlq, na.rm=TRUE),num_rev_accts=median(df$num_rev_accts, na.rm=TRUE), num_acc_ratio=median(df$num_acc_ratio, na.rm=TRUE), inc_instal_ratio=median(df$inc_instal_ratio, na.rm=TRUE), available_bal_instal_ratio=median(df$available_bal_instal_ratio, na.rm=TRUE) ))

colMeans(is.na(df))


#3:

df <- df %>% select(-c(emp_title, title, revol_util, last_pymnt_d,total_pymnt,last_pymnt_amnt, last_credit_pull_d, avg_cur_bal,funded_amnt_inv, term, pymnt_plan, zip_code, addr_state, out_prncp, out_prncp_inv, total_pymnt_inv, total_rec_prncp, total_rec_int,total_rec_late_fee,recoveries, collection_recovery_fee, last_credit_pull_d, policy_code, disbursement_method, debt_settlement_flag, hardship_flag, application_type))



#4:


library(broom)
library(pROC)

glimpse(df)
#We will use the function auc(response, prediction) which returns the AUC value for the specified predictor variable, and considering the response variable as the dependent. 
#   Make sure you understand how this works.
aucAll<- sapply(df %>% mutate_if(is.factor, as.numeric) %>% select_if(is.numeric), auc, response=df$loan_status) 

aucAll[aucAll>0.5]
# or  in any range of values like, tidy(aucAll[aucAll >=0.5 & aucAll < 0.6])
# or in sorted order
tidy(aucAll[aucAll > 0.5]) %>% view()
auc(response=df$loan_status, df$loan_amnt)

######################################################
#   PART - B
######################################################

TRNPROP = 0.7  #proportion of examples in the training sample

rn<-nrow(df)
trnIndex<- sample(1:rn, size = round(TRNPROP * rn), replace=FALSE)

dfTrn <- df[trnIndex, ]
dfTst <- df[-trnIndex, ]

#checking  data
glimpse(df)
colnames(df)
str(df)

library(rpart)
library(ROCR)


#converting loan_status to  a factor variable
df$loan_status <- factor(df$loan_status, levels=c("Fully Paid", "Charged Off"))


varsOmit <- c('actualTerm','actualReturn', 'issue_d', 'annRet','earliest_cr_line')
```
############################
# Best Random Forest Model #
############################
```{r}

#ROC plot
library(ROCR)
library(caret)
library(ranger)


best_rgModel <- ranger(as.factor(loan_status) ~., data=subset(dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)), 
                       num.trees =500,mtry=8,importance="impurity",probability = TRUE,min.node.size=10,max.depth=10,splitrule="gini",regularization.factor=1)


importance_variable<-importance(best_rgModel)
importance_variable
scores=predict(best_rgModel, dfTst,type="response")$predictions 
head(scores)
scores<-scores[,2]
head(scores)

#ROC Curve
pred <- predict(best_rgModel, data = dfTst, num.trees = 200, type='response', verbose = TRUE)
pred_object <- prediction(pred$predictions[,2], dfTst$loan_status)
per_measure <- performance(pred_object, "tnr", "fnr")
plot(per_measure, col="blue", lwd=1)
abline(a=0,b=1,lwd=1,lty=1,col="gray")
#AUC value
aucPerf=performance(pred_object, "auc")
print(aucPerf@y.values)
#Lift curve
liftPerf <-performance(pred_object, "lift", "rpp")
plot(liftPerf)

# for CTHRESH = 0.6
predData = ifelse(scores >= 0.5, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(dfTst$loan_status)))

# for CTHRESH = 0.6
predData = ifelse(scores >= 0.6, "Fully Paid", "Charged Off")
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(dfTst$loan_status)))
# for CTHRESH = 0.7
predData = ifelse(scores >= 0.7, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(dfTst$loan_status)))
# for CTHRESH = 0.8
predData = ifelse(scores >= 0.8, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(dfTst$loan_status)))
# for CTHRESH = 0.85
predData = ifelse(scores >= 0.85, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(dfTst$loan_status)))
# for CTHRESH = 0.9
predData = ifelse(scores >= 0.9, "Fully Paid", "Charged Off") 
predData <- as.factor(predData)
print(confusionMatrix(predData, as.factor(dfTst$loan_status)))
```



############################
# XgBoost Model            #
############################

```{r}
library(xgboost)

# Performing One-Hot-Encoding to convert categorical predicting variable into numerical using dummyVars function of caret
final_df<- df %>% select(-varsOmit)
fdum<-dummyVars(~.,data=final_df %>% select(-loan_status))
dxdf <- predict(fdum, df)


# converting response variable into numeric (0 and 1)
dydf <- class2ind(final_df$loan_status, drop2nd = FALSE)
dydf
class(dydf)


# Created separate dataframe with label = 1 for charged off loans
codf <- dydf [ , 2]
codf

#fpdf <- dydf [ , 1]
#fpdf



#using fraction =0.7, devided dataframe into Training and test subsets
dxdfTrn <- dxdf[trnIndex,]
codfTrn <- codf[trnIndex]
dxdfTst <- dxdf[-trnIndex,]
codfTst <- codf[-trnIndex]

#define final training and testing sets
dxTrn <- xgb.DMatrix( dxdfTrn, label=codfTrn)
dxTst <- xgb.DMatrix( dxdfTst, label=codfTst)

# Creating dataset to watch the performance of learning
xgbWatchlist <- list(train = dxTrn, eval = dxTst)
xgbWatchlist

#Definning parameters
xgbParam <- list (
  max_depth = 5, eta = 0.01, 
  objective = "binary:logistic", 
  eval_metric="error", eval_metric = "auc")

#On Training Data
xgb_lsM1 <- xgb.train( xgbParam, dxTrn, nrounds = 1000,xgbWatchlist, early_stopping_rounds = 10 )
xgb_lsM1$best_iteration
xgb_lsM1$best_score


xgb_lsM1

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM1, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM1, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM1, dxTst)
pred_xgb_lsM1=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM1=performance(pred_xgb_lsM1, "tpr", "fpr")
aucPerf_xgb_lsM1
abline(a=0, b= 1)
```

#Now let's vary parameters and check the perfomance on it
```{r}
xgbParam <- list (
  objective = "binary:logistic", 
  eval_metric="error", eval_metric = "auc")



xgb_lsM2 <- xgb.train( xgbParam, dxTrn, nrounds = 500, xgbWatchlist, early_stopping_rounds = 10, eta=0.5 )
xgb_lsM2$best_iteration
xgb_lsM2$best_score

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM2, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM2, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM2, dxTst)
pred_xgb_lsM2=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM2=performance(pred_xgb_lsM2, "tpr", "fpr")
plot(aucPerf_xgb_lsM2)
abline(a=0, b= 1)




xgb_lsM3 <- xgb.train( xgbParam, dxTrn, nrounds = 500, xgbWatchlist, early_stopping_rounds = 10, eta=0.01 )
xgb_lsM3$best_iteration
xgb_lsM3$best_score

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM3, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM3, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM3, dxTst)
pred_xgb_lsM3=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM3=performance(pred_xgb_lsM3, "tpr", "fpr")
plot(aucPerf_xgb_lsM3)
abline(a=0, b= 1)


xgb_lsM4 <- xgb.train( xgbParam, dxTrn, nrounds = 500, xgbWatchlist, early_stopping_rounds = 10, eta=0.1 )
xgb_lsM4$best_iteration
xgb_lsM4$best_score

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM4, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM4, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM4, dxTst)
pred_xgb_lsM4=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM4=performance(pred_xgb_lsM4, "tpr", "fpr")
plot(aucPerf_xgb_lsM4)
abline(a=0, b= 1)


xgb_lsM5 <- xgb.train( xgbParam, dxTrn, nrounds = 500, xgbWatchlist, early_stopping_rounds = 10, eta=0.1, max_depth=6 )
xgb_lsM5$best_iteration
xgb_lsM5$best_score

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM5, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM5, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM5, dxTst)
pred_xgb_lsM5=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM5=performance(pred_xgb_lsM5, "tpr", "fpr")
plot(aucPerf_xgb_lsM5)
abline(a=0, b= 1)



xgb_lsM6 <- xgb.train( xgbParam, dxTrn, nrounds = 1000, xgbWatchlist, early_stopping_rounds = 10, eta=0.1, max_depth=6 )
xgb_lsM6$best_iteration
xgb_lsM6$best_score

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM6, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM6, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM6, dxTst)
pred_xgb_lsM6=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM6=performance(pred_xgb_lsM6, "tpr", "fpr")
plot(aucPerf_xgb_lsM6)
abline(a=0, b= 1)



xgb_lsM7 <- xgb.train( xgbParam, dxTrn, nrounds = 1000, xgbWatchlist, early_stopping_rounds = 10, eta=0.1, max_depth=6, lambda=0.05 )
xgb_lsM7$best_iteration
xgb_lsM7$best_score

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM7, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM7, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM7, dxTst)
pred_xgb_lsM7=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM7=performance(pred_xgb_lsM7, "tpr", "fpr")
plot(aucPerf_xgb_lsM7)
abline(a=0, b= 1)


xgb_lsM8 <- xgb.train( xgbParam, dxTrn, nrounds = 1000, xgbWatchlist, early_stopping_rounds = 10, eta=0.1, max_depth=6, lambda=0.05, subsample=0.7, colsample_bytree=0.5 )
xgb_lsM8$best_iteration
xgb_lsM8$best_score

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM8, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM8, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM8, dxTst)
pred_xgb_lsM8=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM8=performance(pred_xgb_lsM8, "tpr", "fpr")
plot(aucPerf_xgb_lsM8)
abline(a=0, b= 1)


xgb_lsM9 <- xgb.train( xgbParam, dxTrn, nrounds = 1000, xgbWatchlist, early_stopping_rounds = 10, eta=0.01, max_depth=6, subsample=0.7, colsample_bytree=0.5 )
xgb_lsM9$best_iteration
xgb_lsM9$best_score

# Prediction on Training Data 
xpredTrg<-predict(xgb_lsM9, dxTrn)
xpredTrg
head(xpredTrg)

# Prediction on Testing Data 
xpredTst<-predict(xgb_lsM9, dxTst)
xpredTst
head(xpredTst)

# confusion matrix
table(pred=as.numeric(xpredTrg>0.5), act=codfTrn)
#ROC, AUC performance
xpredTst<-predict(xgb_lsM9, dxTst)
pred_xgb_lsM9=prediction(xpredTst, dfTst$loan_status,label.ordering = c("Fully Paid", "Charged Off"))
aucPerf_xgb_lsM9=performance(pred_xgb_lsM9, "tpr", "fpr")
plot(aucPerf_xgb_lsM9)
abline(a=0, b= 1)


xgb_lsM2$best_score
xgb_lsM3$best_score
xgb_lsM4$best_score
xgb_lsM5$best_score
xgb_lsM6$best_score
xgb_lsM7$best_score
xgb_lsM8$best_score
xgb_lsM9$best_score

# AUC Plots arranged in 3x3
par(mfrow=c(3,3))
plot(aucPerf_xgb_lsM1)
abline(a=0, b= 1)
plot(aucPerf_xgb_lsM2)
abline(a=0, b= 1)
plot(aucPerf_xgb_lsM3)
abline(a=0, b= 1)
plot(aucPerf_xgb_lsM4)
abline(a=0, b= 1)
plot(aucPerf_xgb_lsM5)
abline(a=0, b= 1)
plot(aucPerf_xgb_lsM6)
abline(a=0, b= 1)
plot(aucPerf_xgb_lsM7)
abline(a=0, b= 1)
plot(aucPerf_xgb_lsM8)
abline(a=0, b= 1)
plot(aucPerf_xgb_lsM9)
abline(a=0, b= 1)
```

######################
# Cross Validation #
######################
```{r}

xgb_cv <- xgb.cv( xgbParam, dxTrn, nrounds = 1000, nfold=8, early_stopping_rounds = 10 )
#best iteration
xgb_cv$best_iteration

# or for the best iteration based on performance measure (among those specified in xgbParam)
best_cvIter <- which.max(xgb_cv$evaluation_log$test_auc_mean)
#which.min(xgb_lscv$evaluation_log$test_error_mean)
#learn the best model without xval
xgb_best <- xgb.train( xgbParam, dxTrn, nrounds = xgb_cv$best_iteration )
# variable importance
xgb.importance(model = xgb_best) %>% view()



xgbParamGrid <- expand.grid(
  max_depth = c(2,3,4,5),
  eta = c(0.1,0.01,0.001) )

for(i in 1:nrow(xgbParamGrid)) {
  xgb_tune<- xgboost(data=dxTrn, objective = "reg:squarederror", nrounds=100, eta=xgbParamGrid$eta[i], 
                     max_depth=xgbParamGrid$max_depth[i], early_stopping_rounds = 10)
  xgbParamGrid$bestTree[i] <- xgb_tune$evaluation_log[xgb_tune$best_iteration]$iter
  xgbParamGrid$bestPerf[i] <- xgb_tune$evaluation_log[xgb_tune$best_iteration]$train_rmse
}

xgbParamGrid

```

#Q - 2    GLM

```{r}
library(glmnet)
levels(dfTrn$loan_status)
dfTrn$loan_status<-as.factor(dfTrn$loan_status)


levels(as.factor(dfTst$loan_status))
class(dfTrn$loan_status)
dfTrn$loan_status

yTrn<-factor(if_else(dfTrn$loan_status=="Fully Paid", '1', '0') )
yTrn
xDTrn<-dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
xDTrn
glm_cv<- cv.glmnet(data.matrix(glmTrn), yTrn, family="binomial")

glm_cv$lambda.min
glm_cv$lambda.1se

plot(glm_cv)

coef(glm_cv, s = glm_cv$lambda.min)
coef(glm_cv, s = glm_cv$lambda.1se)

glm_cv$glmnet.fit

glm_cv$lambda.1se


which(glm_cv$lambda == glm_cv$lambda.1se)

glm_cv$glmnet.fit$dev.ratio[which(glm_cv$lambda == glm_cv$lambda.1se) ]

plot(glm_cv$glmnet.fit)      
plot(glm_cv$glmnet.fit, xvar="lambda")

glm_cv_auc<- cv.glmnet(data.matrix(glmTrn), yTrn, family="binomial", type.measure = "auc")
plot(glm_cv_auc)

glm_cv_auc$lambda

glm_cv_auc$cvm

glm_cv_auc$cvm [ which(glm_cv_auc$lambda == glm_cv_auc$lambda.1se) ]

glmRet_Pred_1=predict ( glm_cv,data.matrix(glmTrn), s="lambda.min" )
glmRet_Pred_1_p=predict(glm_cv,data.matrix(glmTrn), s="lambda.min", type="response" )
head(glmRet_Pred_1)
head(glmRet_Pred_1_p)

pred_auc <- prediction(glmRet_Pred_1_p, dfTrn$loan_status, label.ordering = c("Charged Off", "Fully Paid"))
auc_Perf <- performance(pred_auc, "auc")
auc_Perf@y.values

#ROC curve
aucPerf <-performance(pred_auc, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)


#Lift curve
liftPerf <-performance(pred_auc, "lift", "rpp")
plot(liftPerf)

sum(yTrn==0)
sum(yTrn==1)
1-sum(yTrn==0)/length(yTrn)
1-sum(yTrn==1)/length(yTrn)


wght=if_else(yTrn==0,1-sum(yTrn==0)/length(yTrn), 1-sum(yTrn==1)/length(yTrn))
glm_lsw_cv = cv.glmnet(data.matrix(glmTrn),as.factor(yTrn),family="binomial",weights = wght)

summary(yTrn)

colMeans(is.na(glmTrn))

plot(glm_lsw_cv)
tidy(coef(glm_lsw_cv, s=glm_lsw_cv$lambda.1se))
tidy(coef(glm_cv), s=glm_lsw_cv$lambda.1se)

pred_auc <- prediction(glmRet_Pred_1_p, dfTrn$loan_status, label.ordering =c("Charged Off", "Fully Paid"))
auc_Perf <- performance(pred_auc, "auc")
auc_Perf@y.values

#ROC curve
aucPerf <-performance(pred_auc, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)


#Lift curve
liftPerf <-performance(pred_auc, "lift", "rpp")
plot(liftPerf)

glmls_1 <- glmnet(data.matrix(glmTrn), yTrn, family="binomial", lambda = glm_cv$lambda.1se )
glmls_1

glmls_1 <- glmnet(data.matrix(glmTrn), yTrn, family="binomial", lambda = glm_cv$lambda)
tidy(coef(glmls_1, s= glm_cv$lambda.1se))

#Lasso regression
lasCoef <- tidy(coef(glm_cv, s= glm_cv$lambda.1se))
lasCoefVars <- lasCoef[-1,1]       

glmRet_lasv_2 <- glm(yTrn ~ data.matrix(glmTrn %>% select(lasCoefVars)), family=binomial())
summary(glmRet_lasv_2)
tidy(glmRet_lasv_2)


glmTrn<-dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glm_cv<- cv.glmnet(data.matrix(glmTrn), dfTrn$actualReturn, family="gaussian")      

glm_cv$lambda.min      
glm_cv$lambda.1se

coef(glm_cv)
plot(glm_cv)
```


#Q - 2    Ridge Regression and PCA ----

```{r}

#ridge regression
glmRet_cv_rid<- cv.glmnet(data.matrix(glmTrn), dfTrn$actualReturn, family="gaussian", alpha=0)

glmRet_cv_rid$lambda.min      
glmRet_cv_rid$lambda.1se

coef(glmRet_cv_rid)
plot(glmRet_cv_rid)

glmRet_cv_rid2<- cv.glmnet(data.matrix(glmTrn), dfTrn$actualReturn, family="gaussian", alpha=0.2)

glmRet_cv_rid2$lambda.min      
glmRet_cv_rid2$lambda.1se

coef(glmRet_cv_rid2)
plot(glmRet_cv_rid2)

glmRet_rid3<- glmnet(data.matrix(glmTrn), dfTrn$actualReturn, family="gaussian", alpha=0.5)
plot(glmRet_rid3)      

vars_nz<-coef(glmRet_cv_rid2, s="lambda.1se") %>% tidy()
vars_nz <- vars_nz[-1,1]

glmRet_cv_rid2_nzv <- glm( dfTrn$actualReturn ~ data.matrix(glmTrn %>% select(lasCoefVars)), family=gaussian())

summary(glmRet_cv_rid2_nzv)

qqnorm(xDTrn$int_rate)
qqline(xDTrn$int_rate)

qqnorm(xDTrn$acc_open_past_24mths)
qqline(xDTrn$acc_open_past_24mths)

qqnorm(xDTrn$dti)
qqline(xDTrn$dti)

library(corrplot)

xCorr <- xDTrn %>% select_if(is.numeric) %>% cor()
corrplot(xCorr, method="circle")

corrTH = 0.6
xCorr[upper.tri(xCorr, diag=TRUE)] <- NA
xCorr[1:3,1:3]
dim(xCorr)

xCorr <- as.data.frame(as.table(xCorr))
xCorr[1:3,]
dim(xCorr)

xCorr <- na.omit(xCorr) 
xCorr_th <- xCorr %>% filter(abs(Freq) > corrTH )
xCorr_th <- xCorr_th[order(-abs(xCorr_th$Freq)),] 

xCorr_th[1:3,] 
dim(xCorr_th)


xCorrMat <- xCorr_th %>% pivot_wider(names_from = Var2, values_from = Freq)   
xCorrMat[1:3,1:3] 
dim(xCorrMat)

xCorrMat<-column_to_rownames(xCorrMat, var="Var1")
xCorrMat[1:5,1:5]

corrplot(as.matrix(xCorrMat), is.corr=FALSE, na.label=" ", method="circle")


xDTrn<-dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)

fdum<-dummyVars(~.,data=xDTrn)
xDnTrn <- predict(fdum, xDTrn)

xD_pca <-prcomp (xDnTrn,scale=TRUE )
summary(xD_pca)

xD_pca$sdev
plot(xD_pca, type="lines")

cumsum(xD_pca$sdev/sum(xD_pca$sdev))
plot(cumsum(xD_pca$sdev/sum(xD_pca$sdev)))

library(factoextra)

fviz_pca_var(xD_pca)
fviz_pca_var(xD_pca, select.var = list(cos2=20))
fviz_pca_var(xD_pca, select.var = list(cos2=20),col.var = "contrib", repel=TRUE )    
fviz_pca_var(xD_pca, select.var = list(cos2=20))

```
#Sampling using ROSE Library

```{r}

library(ranger)
library(rsample)
library(xgboost)
library(ROSE)

dfSplit<-initial_split(df, prop=0.7)
dfTrn<-training(dfSplit)
dfTst<-testing(dfSplit)


us_dfTrn<-ovun.sample(loan_status~., data = as.data.frame(dfTrn), na.action = na.pass, method="under", p=0.5)$data
os_dfTrn<-ovun.sample(loan_status~., data = as.data.frame(dfTrn), na.action = na.pass, method="over", p=0.5)$data
bs_dfTrn<-ovun.sample(loan_status~., data = as.data.frame(dfTrn), na.action = na.pass, method="both", p=0.5)$data

us_dfTrn %>% group_by(loan_status) %>% count()
os_dfTrn %>% group_by(loan_status) %>% count()
bs_dfTrn %>% group_by(loan_status) %>% count()



#Without Sampling
#Random Forest
#actualReturn
rfModel_Ret <- ranger(dfTrn$actualReturn ~., data=subset(dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)),num.trees =500, importance='permutation')

rfPredRet_trn<- predict(rfModel_Ret, dfTst)
sqrt(mean( (rfPredRet_trn$predictions - dfTst$actualReturn)^2))
#plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)
#plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)


predRet_Trn <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet=(predict(rfModel_Ret, dfTst))$predictions)
predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" 
                                             ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F"))


#Without Sampling
#Random Forest
#loan_status
rfModel_Ret <- ranger(as.factor(dfTrn$loan_status) ~., data=subset(dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)), 
                      num.trees =500,mtry=8,importance="impurity",probability = TRUE,min.node.size=10,max.depth=10,splitrule="gini",regularization.factor=1)

rfPredRet_Tst<- predict(rfModel_Ret, dfTst)
predRet_Tst <- dfTst %>% select(grade, loan_status, loan_status, actualTerm,actualReturn, int_rate) %>% mutate(predRet=rfPredRet_Tst$predictions)
predRet_Tst <- predRet_Tst %>% mutate(tile=ntile(predRet[,2], 10))
predRet_Tst %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" 
                                             ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )


#Without Sampling
#XGBoost
#loan_status
final_df<- df %>% select(-varsOmit)
fdum<-dummyVars(~.,data=final_df %>% select(-loan_status))
dxdf <- predict(fdum, df)


# converting response variable into numeric (0 and 1)
dydf <- class2ind(final_df$loan_status, drop2nd = FALSE)
dydf
# Converted separate df for loan_status = Fully paid and charged off, so later we can use any of them as required
fpdf <- dydf [ , 1]
fpdf
codf <- dydf [ , 2]
codf


#Training, test subsets
dxdfTrn <- dxdf[trnIndex,]
codfTrn <- codf[trnIndex]
dxdfTst <- dxdf[-trnIndex,]
codfTst <- codf[-trnIndex]

#define final training and testing sets
dxTrn <- xgb.DMatrix( dxdfTrn, label=codfTrn)
dxTst <- xgb.DMatrix( dxdfTst, label=codfTst)

# Creating dataset to watch the performance of learning
xgbWatchlist <- list(train = dxTrn, eval = dxTst)

xgbParam <- list (
  objective = "binary:logistic", 
  eval_metric="error", eval_metric = "auc")

xgb_lsM7 <- xgb.train( xgbParam, dxTrn, nrounds = 1000, xgbWatchlist, early_stopping_rounds = 10, eta=0.1, max_depth=6, lambda=0.05 )

xpredTst<-predict(xgb_lsM7, dxTst)
scoreTst_xgb_ls <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(score=xpredTst)
scoreTst_xgb_ls <- scoreTst_xgb_ls %>% mutate(tile=ntile(-score, 10))
scoreTst_xgb_ls %>% group_by(tile) %>% summarise(count=n(), avgSc=mean(score), numDefaults=sum(loan_status=="Charged Off"), 
                                                 avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                                 totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )



#Without Sampling
#XGBoost
#actualReturn





#Without Sampling
#GLM
#actualReturn
xD<-dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), dfTrn$actualReturn, family="gaussian")
predRet_Trn <- dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                    s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, dfTrn)
sqrt(mean( (rfPredRet_trn$predictions - dfTrn$actualReturn)^2))

predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )





#Without Sampling
#GLM
#loan_status
xD<-dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), dfTrn$loan_status, family="binomial")
predRet_Trn <- dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                    s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, dfTrn)
sqrt(mean( (rfPredRet_trn$predictions - dfTrn$actualReturn)^2))

predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )




#underSampling
#Random Forest
#actualReturn


rfModel_Ret <- ranger(us_dfTrn$actualReturn ~., data=subset(us_dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)),num.trees =500, importance='permutation')

rfPredRet_trn<- predict(rfModel_Ret, dfTst)
sqrt(mean( (rfPredRet_trn$predictions - dfTst$actualReturn)^2))
#plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)
#plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)


predRet_Trn <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet=(predict(rfModel_Ret, dfTst))$predictions)
predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" 
                                             ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F"))


#underSampling
#Random Forest
#loan_status


rfModel_Ret <- ranger(as.factor(us_dfTrn$loan_status) ~., data=subset(us_dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)), 
                      num.trees =500,mtry=8,importance="impurity",probability = TRUE,min.node.size=10,max.depth=10,splitrule="gini",regularization.factor=1)

rfPredRet_Tst<- predict(rfModel_Ret, dfTst)
predRet_Tst <- dfTst %>% select(grade, loan_status, loan_status, actualTerm,actualReturn, int_rate) %>% mutate(predRet=rfPredRet_Tst$predictions)
predRet_Tst <- predRet_Tst %>% mutate(tile=ntile(predRet[,2], 10))
predRet_Tst %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" 
                                             ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )


#underSampling
#XGBoost
#loan_status


final_df<- df %>% select(-varsOmit)
fdum<-dummyVars(~.,data=final_df %>% select(-loan_status))
dxdf <- predict(fdum, df)


# converting response variable into numeric (0 and 1)
dydf <- class2ind(final_df$loan_status, drop2nd = FALSE)
dydf
# Converted separate df for loan_status = Fully paid and charged off, so later we can use any of them as required
fpdf <- dydf [ , 1]
fpdf
codf <- dydf [ , 2]
codf


#Training, test subsets
dxdfTrn <- dxdf[trnIndex,]
codfTrn <- codf[trnIndex]
dxdfTst <- dxdf[-trnIndex,]
codfTst <- codf[-trnIndex]

#define final training and testing sets
dxTrn <- xgb.DMatrix( dxdfTrn, label=codfTrn)
dxTst <- xgb.DMatrix( dxdfTst, label=codfTst)

# Creating dataset to watch the performance of learning
xgbWatchlist <- list(train = dxTrn, eval = dxTst)

xgbParam <- list (
  objective = "binary:logistic", 
  eval_metric="error", eval_metric = "auc")

xgb_lsM7 <- xgb.train( xgbParam, dxTrn, nrounds = 1000, xgbWatchlist, early_stopping_rounds = 10, eta=0.1, max_depth=6, lambda=0.05 )

xpredTst<-predict(xgb_lsM7, dxTst)
scoreTst_xgb_ls <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(score=xpredTst)
scoreTst_xgb_ls <- scoreTst_xgb_ls %>% mutate(tile=ntile(-score, 10))
scoreTst_xgb_ls %>% group_by(tile) %>% summarise(count=n(), avgSc=mean(score), numDefaults=sum(loan_status=="Charged Off"), 
                                                 avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                                 totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )



#underSampling
#XGBoost
#actualReturn





#underSampling
#GLM
#actualReturn



xD<-us_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), us_dfTrn$actualReturn, family="gaussian")
predRet_Trn <- us_dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(us_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                       s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, us_dfTrn)
sqrt(mean( (rfPredRet_trn$predictions - us_dfTrn$actualReturn)^2))

predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )





#underSampling
#GLM
#loan_status



xD<-us_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), us_dfTrn$loan_status, family="binomial")
predRet_Trn <- us_dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(us_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                       s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, us_dfTrn)
sqrt(mean( (rfPredRet_trn$predictions - us_dfTrn$actualReturn)^2))

predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )




#overSampling
#Random Forest
#actualReturn


rfModel_Ret <- ranger(os_dfTrn$actualReturn ~., data=subset(os_dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)),num.trees =500, importance='permutation')

rfPredRet_trn<- predict(rfModel_Ret, dfTst)
sqrt(mean( (rfPredRet_trn$predictions - dfTst$actualReturn)^2))
#plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)
#plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)


predRet_Trn <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet=(predict(rfModel_Ret, dfTst))$predictions)
predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" 
                                             ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F"))


#overSampling
#Random Forest
#loan_status


rfModel_Ret <- ranger(as.factor(os_dfTrn$loan_status) ~., data=subset(os_dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)), 
                      num.trees =500,mtry=8,importance="impurity",probability = TRUE,min.node.size=10,max.depth=10,splitrule="gini",regularization.factor=1)

rfPredRet_Tst<- predict(rfModel_Ret, dfTst)
predRet_Tst <- dfTst %>% select(grade, loan_status, loan_status, actualTerm,actualReturn, int_rate) %>% mutate(predRet=rfPredRet_Tst$predictions)
predRet_Tst <- predRet_Tst %>% mutate(tile=ntile(predRet[,2], 10))
predRet_Tst %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" 
                                             ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )


#overSampling
#XGBoost
#loan_status


final_df<- df %>% select(-varsOmit)
fdum<-dummyVars(~.,data=final_df %>% select(-loan_status))
dxdf <- predict(fdum, df)


# converting response variable into numeric (0 and 1)
dydf <- class2ind(final_df$loan_status, drop2nd = FALSE)
dydf
# Converted separate df for loan_status = Fully paid and charged off, so later we can use any of them as required
fpdf <- dydf [ , 1]
fpdf
codf <- dydf [ , 2]
codf


#Training, test subsets
dxdfTrn <- dxdf[trnIndex,]
codfTrn <- codf[trnIndex]
dxdfTst <- dxdf[-trnIndex,]
codfTst <- codf[-trnIndex]

#define final training and testing sets
dxTrn <- xgb.DMatrix( dxdfTrn, label=codfTrn)
dxTst <- xgb.DMatrix( dxdfTst, label=codfTst)

# Creating dataset to watch the performance of learning
xgbWatchlist <- list(train = dxTrn, eval = dxTst)

xgbParam <- list (
  objective = "binary:logistic", 
  eval_metric="error", eval_metric = "auc")

xgb_lsM7 <- xgb.train( xgbParam, dxTrn, nrounds = 1000, xgbWatchlist, early_stopping_rounds = 10, eta=0.1, max_depth=6, lambda=0.05 )

xpredTst<-predict(xgb_lsM7, dxTst)
scoreTst_xgb_ls <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(score=xpredTst)
scoreTst_xgb_ls <- scoreTst_xgb_ls %>% mutate(tile=ntile(-score, 10))
scoreTst_xgb_ls %>% group_by(tile) %>% summarise(count=n(), avgSc=mean(score), numDefaults=sum(loan_status=="Charged Off"), 
                                                 avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                                 totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )



#overSampling
#XGBoost
#actualReturn





#overSampling
#GLM
#actualReturn



xD<-os_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), os_dfTrn$actualReturn, family="gaussian")
predRet_Trn <- os_dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(os_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                       s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, os_dfTrn)
sqrt(mean( (rfPredRet_trn$predictions - os_dfTrn$actualReturn)^2))

predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )





#overSampling
#GLM
#loan_status



xD<-os_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), os_dfTrn$loan_status, family="binomial")
predRet_Trn <- os_dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(os_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                       s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, os_dfTrn)
sqrt(mean( (rfPredRet_trn$predictions - os_dfTrn$actualReturn)^2))

predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )




#bothSampling
#Random Forest
#actualReturn


rfModel_Ret <- ranger(bs_dfTrn$actualReturn ~., data=subset(bs_dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)),num.trees =500, importance='permutation')

rfPredRet_trn<- predict(rfModel_Ret, dfTst)
sqrt(mean( (rfPredRet_trn$predictions - dfTst$actualReturn)^2))
#plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)
#plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)


predRet_Trn <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet=(predict(rfModel_Ret, dfTst))$predictions)
predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" 
                                             ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F"))


#bothSampling
#Random Forest
#loan_status


rfModel_Ret <- ranger(as.factor(bs_dfTrn$loan_status) ~., data=subset(bs_dfTrn, select=-c(annRet,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d,actualTerm,actualReturn)), 
                      num.trees =500,mtry=8,importance="impurity",probability = TRUE,min.node.size=10,max.depth=10,splitrule="gini",regularization.factor=1)

rfPredRet_Tst<- predict(rfModel_Ret, dfTst)
predRet_Tst <- dfTst %>% select(grade, loan_status, loan_status, actualTerm,actualReturn, int_rate) %>% mutate(predRet=rfPredRet_Tst$predictions)
predRet_Tst <- predRet_Tst %>% mutate(tile=ntile(predRet[,2], 10))
predRet_Tst %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" 
                                             ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )


#bothSampling
#XGBoost
#loan_status


final_df<- df %>% select(-varsOmit)
fdum<-dummyVars(~.,data=final_df %>% select(-loan_status))
dxdf <- predict(fdum, df)


# converting response variable into numeric (0 and 1)
dydf <- class2ind(final_df$loan_status, drop2nd = FALSE)
dydf
# Converted separate df for loan_status = Fully paid and charged off, so later we can use any of them as required
fpdf <- dydf [ , 1]
fpdf
codf <- dydf [ , 2]
codf


#Training, test subsets
dxdfTrn <- dxdf[trnIndex,]
codfTrn <- codf[trnIndex]
dxdfTst <- dxdf[-trnIndex,]
codfTst <- codf[-trnIndex]

#define final training and testing sets
dxTrn <- xgb.DMatrix( dxdfTrn, label=codfTrn)
dxTst <- xgb.DMatrix( dxdfTst, label=codfTst)

# Creating dataset to watch the performance of learning
xgbWatchlist <- list(train = dxTrn, eval = dxTst)

xgbParam <- list (
  objective = "binary:logistic", 
  eval_metric="error", eval_metric = "auc")

xgb_lsM7 <- xgb.train( xgbParam, dxTrn, nrounds = 1000, xgbWatchlist, early_stopping_rounds = 10, eta=0.1, max_depth=6, lambda=0.05 )

xpredTst<-predict(xgb_lsM7, dxTst)
scoreTst_xgb_ls <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(score=xpredTst)
scoreTst_xgb_ls <- scoreTst_xgb_ls %>% mutate(tile=ntile(-score, 10))
scoreTst_xgb_ls %>% group_by(tile) %>% summarise(count=n(), avgSc=mean(score), numDefaults=sum(loan_status=="Charged Off"), 
                                                 avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                                 totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )



#bothSampling
#XGBoost
#actualReturn





#bothSampling
#GLM
#actualReturn



xD<-bs_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), bs_dfTrn$actualReturn, family="gaussian")
predRet_Trn <- bs_dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(bs_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                       s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, bs_dfTrn)
sqrt(mean( (rfPredRet_trn$predictions - bs_dfTrn$actualReturn)^2))

predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )


#bothSampling
#GLM
#loan_status


xD<-bs_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), bs_dfTrn$loan_status, family="binomial")
predRet_Trn <- bs_dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(bs_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                       s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, dfTrn)
sqrt(mean( (rfPredRet_trn$predictions - bs_dfTrn$actualReturn)^2))

predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )

```
#Q-3
```{r}
####################
# Q - 3            #
####################
library(rpart)
library(broom)
library(pROC)
library(ROCR)
library(caret)
library(ranger)
library(xgboost)
library(glmnet)
library(corrplot)
library(rsample)
library(ROSE)

colnames(dfTrn)
rfModel_Ret <- ranger(actualReturn ~., data=subset(dfTrn, select=-c(annRet,	actualTerm,bc_open_to_buy,collections_12_mths_ex_med,delinq_amnt,dti,funded_amnt,issue_d)), num.trees =200,importance='permutation')

rfPredRet_trn<- predict(rfModel_Ret, dfTrn)

sqrt(mean( (rfPredRet_trn$predictions - dfTrn$actualReturn)^2))
#sqrt(mean( ( (predict(rfModel_Ret, dfTst))$predictions - dfTst$actualReturn)^2))
plot ( (predict(rfModel_Ret, dfTst))$predictions, dfTst$actualReturn)
plot ( (predict(rfModel_Ret, dfTrn))$predictions, dfTrn$actualReturn)


predRet_Trn <- dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet=(predict(rfModel_Ret, dfTrn))$predictions)
predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"),avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B"), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )



xD<-dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), dfTrn$actualReturn, family="gaussian")
predRet_Trn <- dfTrn %>% select(grade, loan_status, actualReturn, actualTerm, int_rate)%>% mutate(predRet= predict(glmRet_cv, data.matrix(dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),s="lambda.min" ) )
predRet_Trn <- predRet_Trn %>% mutate(tile=ntile(-predRet, 10))
predRet_Trn %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"),avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"),totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )


```


#Q-4
```{r}

#M1 Model

xD<-bs_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv<- cv.glmnet(data.matrix(xD), bs_dfTrn$loan_status, family="binomial")
predRet_Tst_m1 <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRet= predict(glmRet_cv, data.matrix(dfTst %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                                       s="lambda.min" ) )

rfPredRet_trn<- predict(rfModel_Ret, dfTst)
sqrt(mean( (rfPredRet_trn$predictions - dfTst$actualReturn)^2))

predRet_Tst_m1 <- predRet_Tst_m1 %>% mutate(tile=ntile(-predRet, 10))
predRet_Tst_m1 %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRet), numDefaults=sum(loan_status=="Charged Off"), 
                                             avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                             totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )

#M2 Model


xDM2<-bs_dfTrn %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)
glmRet_cv_M2<- cv.glmnet(data.matrix(xDM2), bs_dfTrn$actualReturn, family="gaussian")
predRet_Tst_m2 <- dfTst %>% select(grade, loan_status, actualReturn, actualTerm, int_rate) %>% mutate(predRetm2= predict(glmRet_cv_M2, data.matrix(dfTst %>% select(-loan_status, -actualTerm, -annRet, -actualReturn)),
                                                                                                         s="lambda.min" ) )


predRet_Tst_m2 <- predRet_Tst_m2 %>% mutate(tile=ntile(-predRetm2, 10))
predRet_Tst_m2 %>% group_by(tile) %>% summarise(count=n(), avgpredRet=mean(predRetm2), numDefaults=sum(loan_status=="Charged Off"), 
                                                avgActRet=mean(actualReturn), minRet=min(actualReturn), maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), 
                                                totB=sum(grade=="B" ), totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )

# selected top decile from M1 model to place in M2 model

d=1
pRetpred <- predRet_Tst_m2 %>% mutate(poScore=predRet_Tst_m1$predRet)
pRet_decile <- pRetpred %>% filter(tile<=d)
pRet_decile<- pRet_decile %>% mutate(tile2=ntile(-poScore, 20))
pRet_decile %>% group_by(tile2) %>% summarise(count=n(), avgPredRet=mean(predRetm2), 
                                              numDefaults=sum(loan_status=="Charged Off"), avgActRet=mean(actualReturn), minRet=min(actualReturn), 
                                              maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" ),
                                              totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )


#Multiplied predRetm2 with poScore to find expected return
pRet_decile<- pRet_decile %>% mutate(expRet=predRetm2*poScore)
pRet_decile<- pRet_decile %>% mutate(tile2=ntile(-expRet, 20))
pRet_decile %>% group_by(tile2) %>% summarise(count=n(), avgPredRet=mean(predRetm2), 
                                              numDefaults=sum(loan_status=="Charged Off"), avgActRet=mean(actualReturn), minRet=min(actualReturn), 
                                              maxRet=max(actualReturn), avgTer=mean(actualTerm), totA=sum(grade=="A"), totB=sum(grade=="B" ), 
                                              totC=sum(grade=="C"), totD=sum(grade=="D"), totE=sum(grade=="E"), totF=sum(grade=="F") )

```

#Q-5
```{r}


```
